<link defer rel="import" href="../../bower_components/polymer/polymer.html" />
<link defer rel="import" href="../../bower_components/px-demo/px-demo-theme-util.html"/>

<dom-module id="px-catalog-page-viewer">
  <template>
    <style>
      :host {
        position: relative;
        background-color: var(--px-catalog-page-background-color, white);
      }

      :host([dark-theme]) {
        background-color: var(--px-catalog-page-background-color, black);
      }

      #pages {
        flex: 1 1 auto;
        margin: 0;
        padding: 0;
      }

      #pages > ::slotted(:not(.active)) {
        display: none;
      }

      .spinner {
        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        right: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }
    </style>
    <!-- Pages will be distributed here -->
    <div id="pages"></div>
    <template is="dom-if" if="[[spinnerActive]]">
      <div class="spinner">
        <px-spinner size="150"></px-spinner>
      </div>
    </template>
  </template>
  <script>
    Polymer({
      is: 'px-catalog-page-viewer',
      properties: {
        activeModule: {
          type: String,
          observer: '_activeModuleChanged'
        },
        darkTheme: {
          type: Boolean,
          value: false,
          reflectToAttribute: true
        },
        spinnerActive: {
          type: Boolean,
          value: false
        },
        _activeModuleEl: {
          type: HTMLElement
        },
        _scrollTop: {
          type: Number,
          value: null
        }
      },
      observers: [
        '_applyTheme(_activeModuleEl, darkTheme)',
        '_checkVisibleAnchor(activeModule, _activeModuleEl, _scrollTop)'
      ],
      listeners: {
        'px-catalog-page-attached': '_handleLocalPageAttached',
        'px-catalog-page-detached': '_handleLocalPageDetached'
      },
      created: function() {
        this._modules = {};

        // Checks if passive scroll handler is supported. If it isn't (e.g. in
        // old browsers) the anchor navigation links will not be updated as
        // the user scrolls. This test is from https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
        var passiveScrollSupported = false;
        try {
          var options = Object.defineProperty({}, "passive", {
            get: function() {
              passiveScrollSupported = true;
            }
          });

          window.addEventListener("test", null, options);
        } catch(err) {}
        this._passiveScrollSupported = passiveScrollSupported;
      },
      attached: function() {
        if (this._passiveScrollSupported) {
          this._scrollHandler = this._handleScroll.bind(this);
          this.addEventListener('scroll', this._scrollHandler, { passive: true });
        }
      },
      detached: function() {
        if (this._passiveScrollSupported && this._scrollHandler) {
          this.removeEventListener('scroll', this._scrollHandler, { passive: true });
        }
      },
      _handleScroll: function(evt) {
        this.debounce('handle-scroll', function() {
          this._scrollTop = this.scrollTop;
        }, 100);
      },
      _checkVisibleAnchor: function(viewName, viewEl, scroll) {
        if (viewName.slice(0,5) !== 'view-' || typeof scroll !== 'number' || !(viewEl instanceof HTMLElement) || !viewEl.hasAttribute('has-anchors')) {
          return;
        }
        var anchors = viewEl.anchors;

        var offsetPadding = 75;
        var firstAnchorOffset = anchors[0].offsetTop - offsetPadding;
        var anchorsLength = anchors.length
        var lastAnchorOffset = anchors[anchorsLength-1].offsetTop - offsetPadding;

        //scroll is above the first anchor point
        if (scroll === 0 || scroll < firstAnchorOffset){ viewEl.activeAnchor = '';}

        for (var i=0; i<anchors.length; i++) {
          var topRange = anchors[i].offsetTop - offsetPadding;
          var bottomRange;

          // find bottom range of i's anchor point
          // if i is the last anchor point set the bottom range to the scroll height
          if(i < anchors.length-1){
            bottomRange = anchors[i+1].offsetTop - offsetPadding;
          }else if (scroll > firstAnchorOffset && bottomRange === undefined){
            bottomRange = this.scrollHeight;
          }

          if (scroll > topRange && scroll < bottomRange ){
            viewEl.activeAnchor = '#' + anchors[i].id; break;
          }
        }
      },
      _handleLocalPageAttached: function(evt) {
        // ... local page attached ...
      },
      _handleLocalPageDetached: function(evt) {
        // ... local page detached ...
      },
      _activeModuleChanged: function(newModuleName, oldModuleName) {
        this.scrollTop = 0;
        var lastActive = Polymer.dom(this.$.pages).querySelector('.active');
        if (lastActive !== null) {
          lastActive.classList.remove('active');
          if (lastActive.hasAttribute('dark-theme')) {
            lastActive.removeAttribute('dark-theme');
          }
        }
        if (newModuleName && !this._modules[newModuleName]) {
          var el = document.createElement(newModuleName);
          Polymer.dom(this.$.pages).appendChild(el);
          this._modules[newModuleName] = el;
        }
        if (newModuleName) {
          this._modules[newModuleName].classList.add('active');
          if (this.darkTheme && !this._modules[newModuleName].hasAttribute('darkTheme')) {
            this._modules[newModuleName].setAttribute('dark-theme', '');
          }
          this._activeModuleEl = this._modules[newModuleName];
        }
      },
      _applyTheme: function(el, darkTheme, retry) {
        retry = retry || 1;
        if (!el) {
          return;
        }
        if (!el.is && retry < 100) {
          var retries = (retry+1);
          var timeout = (retries > 10) ? 10 : 100;
          this.async(this._applyTheme.bind(this, el, darkTheme, retries), timeout);
          return;
        }

        var componentDemoRe = /px\-[a-zA-Z0-9-]+-demo/;
        var isComponentDemo = componentDemoRe.test(el.nodeName.toLowerCase());

        if (darkTheme && isComponentDemo) {
          var darkTheme = PxDemo.ThemeUtil.getDarkThemeProperties();
          el.updateStyles(darkTheme);
        }
        else if (!darkTheme && isComponentDemo) {
          var defaultTheme = PxDemo.ThemeUtil.getDefaultThemeProperties();
          el.updateStyles(defaultTheme);
        }
        else if (darkTheme && !isComponentDemo) {
          el.setAttribute('dark-theme', '');
          el.updateStyles();
        }
        else if (!darkTheme && !isComponentDemo) {
          el.removeAttribute('dark-theme');
          el.updateStyles();
        }
      }
    })
  </script>
</dom-module>
